---
interface Stat {
  value: string;
  label: string;
  suffix?: string;
}

const stats: Stat[] = [
  { value: '50', suffix: '+', label: 'Entreprises accompagnées' },
  { value: '99.9', suffix: '%', label: 'Disponibilité garantie' },
  { value: '500', suffix: '+', label: 'Workflows automatisés' },
  { value: '24', suffix: '/7', label: 'Support technique' },
];
---

<section class="stats section-stone">
  <div class="stats-texture"></div>
  <div class="container">
    <div class="stats-grid">
      {stats.map((stat, index) => (
        <div class="stat-item card-stone" style={`--delay: ${index * 0.1}s`}>
          <div class="stat-value">
            <span class="stat-number" data-value={stat.value}>{stat.value}</span>
            {stat.suffix && <span class="stat-suffix">{stat.suffix}</span>}
          </div>
          <div class="stat-label">{stat.label}</div>
        </div>
      ))}
    </div>
    <p class="stats-disclaimer">* Chiffres basés sur nos clients actifs</p>
  </div>
</section>

<style>
  .stats {
    padding: var(--spacing-2xl) 0;
    position: relative;
    z-index: 1;
  }

  /* Stone texture overlay */
  .stats-texture {
    position: absolute;
    inset: 0;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.7' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
    opacity: 0.035;
    pointer-events: none;
  }

  /* Top edge highlight - like polished stone */
  .stats::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 1px;
    background: linear-gradient(90deg, transparent 0%, rgba(148, 163, 184, 0.4) 50%, transparent 100%);
    z-index: 1;
  }

  /* Bottom edge shadow - grounded feel */
  .stats::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 1px;
    background: linear-gradient(90deg, transparent 0%, rgba(0, 0, 0, 0.3) 50%, transparent 100%);
  }

  .stats .container {
    position: relative;
    z-index: 100;
  }

  .stats-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: var(--spacing-lg);
  }

  .stat-item {
    text-align: center;
    animation: fade-in-up 0.6s ease forwards;
    animation-delay: var(--delay);
    opacity: 0;
  }

  @keyframes fade-in-up {
    to {
      opacity: 1;
      transform: translateY(0);
    }
    from {
      opacity: 0;
      transform: translateY(20px);
    }
  }

  .stat-value {
    display: flex;
    align-items: baseline;
    justify-content: center;
    gap: 0.125rem;
    margin-bottom: 0.5rem;
  }

  .stat-number {
    font-family: var(--font-heading);
    font-size: clamp(2.5rem, 4vw, 3.5rem);
    font-weight: 700;
    background: linear-gradient(135deg, #60a5fa 0%, #93c5fd 50%, #60a5fa 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .stat-suffix {
    font-family: var(--font-heading);
    font-size: clamp(1.5rem, 2.5vw, 2rem);
    font-weight: 600;
    color: var(--color-accent-light);
  }

  .stat-label {
    font-size: 0.9375rem;
    color: var(--color-gray-400);
    font-weight: 500;
  }

  .stats-disclaimer {
    text-align: center;
    margin-top: var(--spacing-lg);
    font-size: 0.8125rem;
    color: var(--color-gray-500);
    font-style: italic;
    position: relative;
    z-index: 1;
  }

  @media (max-width: 1024px) {
    .stats-grid {
      grid-template-columns: repeat(2, 1fr);
    }
  }

  @media (max-width: 640px) {
    .stats-grid {
      grid-template-columns: 1fr;
    }

    .stat-item {
      padding: var(--spacing-md);
    }
  }
</style>

<script>
  // Counter animation
  const observerOptions = {
    threshold: 0.5,
    rootMargin: '0px'
  };

  const animateCounter = (element: Element) => {
    const target = parseFloat(element.getAttribute('data-value') || '0');
    const duration = 2000;
    const start = performance.now();
    const isDecimal = target % 1 !== 0;

    const updateCounter = (currentTime: number) => {
      const elapsed = currentTime - start;
      const progress = Math.min(elapsed / duration, 1);
      const easeOut = 1 - Math.pow(1 - progress, 3);
      const current = target * easeOut;

      element.textContent = isDecimal ? current.toFixed(1) : Math.floor(current).toString();

      if (progress < 1) {
        requestAnimationFrame(updateCounter);
      }
    };

    requestAnimationFrame(updateCounter);
  };

  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const counters = entry.target.querySelectorAll('.stat-number');
        counters.forEach(counter => animateCounter(counter));
        observer.unobserve(entry.target);
      }
    });
  }, observerOptions);

  const statsSection = document.querySelector('.stats');
  if (statsSection) {
    observer.observe(statsSection);
  }
</script>
